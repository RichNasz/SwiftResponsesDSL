//
//  CustomExtensions.swift
//  SwiftResponsesDSL Examples
//
//  Advanced examples showing how to create custom extensions
//  and specialized components for domain-specific use cases.
//
//  Generated by AI-assisted code generation.
//  Created by Richard Naszcyniec on [Date].
//  Copyright ¬© [Year] Richard Naszcyniec. All rights reserved.
//

import SwiftResponsesDSL

/// Example 1: Custom Parameter Types
/// Shows how to create domain-specific parameter configurations
func customParameterTypesExample() async throws {
    print("üéØ Custom Parameter Types")
    print("========================")

    // Define custom parameter structs for a specific domain
    struct ReadingLevel: ResponseConfigParameter {
        let level: String

        init(_ level: String) throws {
            let validLevels = ["elementary", "middle_school", "high_school", "college", "graduate"]
            guard validLevels.contains(level) else {
                throw LLMError.invalidValue("Reading level must be one of: \(validLevels.joined(separator: ", "))")
            }
            self.level = level
        }

        func apply(to request: inout ResponseRequest) throws {
            // Custom logic for reading level
            let systemPrompt = "Explain concepts at a \(level) reading level. Use appropriate vocabulary and examples."
            if let existingSystem = request.input.first(where: { $0.role == .system }) {
                // Combine with existing system message
                request.input = request.input.map { message in
                    if message.role == .system {
                        return SystemMessage(text: "\(existingSystem.content.first?.text ?? "")\n\(systemPrompt)")
                    }
                    return message
                }
            } else {
                request.input.insert(SystemMessage(text: systemPrompt), at: 0)
            }
        }
    }

    struct ContentFilter: ResponseConfigParameter {
        let level: String

        init(_ level: String) throws {
            let validLevels = ["strict", "moderate", "permissive"]
            guard validLevels.contains(level) else {
                throw LLMError.invalidValue("Filter level must be one of: \(validLevels.joined(separator: ", "))")
            }
            self.level = level
        }

        func apply(to request: inout ResponseRequest) throws {
            let filterPrompt = "Apply \(level) content filtering. Avoid inappropriate topics and maintain professional tone."
            if let existingSystem = request.input.first(where: { $0.role == .system }) {
                request.input = request.input.map { message in
                    if message.role == .system {
                        return SystemMessage(text: "\(existingSystem.content.first?.text ?? "")\n\(filterPrompt)")
                    }
                    return message
                }
            } else {
                request.input.insert(SystemMessage(text: filterPrompt), at: 0)
            }
        }
    }

    let client = try LLMClient(baseURLString: "https://api.openai.com/v1/responses")

    // Use custom parameters in a request
    let request = try ResponseRequest(
        model: "gpt-4",
        config: {
            ReadingLevel("middle_school")  // Custom parameter
            ContentFilter("moderate")      // Another custom parameter
            Temperature(0.7)
        },
        input: {
            user("Explain how photosynthesis works")
        }
    )

    print("üìö Using custom educational parameters...")
    let response = try await client.respond(to: request)

    if let explanation = response.choices.first?.message.content {
        print("ü§ñ Educational explanation:")
        print("   \(explanation)")
    }

    print("‚úÖ Custom parameter types demonstrated!")
}

/// Example 2: Domain-Specific Builders
/// Shows how to create specialized builders for specific use cases
func domainSpecificBuildersExample() async throws {
    print("\nüèóÔ∏è  Domain-Specific Builders")
    print("===========================")

    // Create a specialized builder for educational content
    @resultBuilder
    struct EducationalBuilder {
        static func buildBlock(_ components: EducationalComponent...) -> [EducationalComponent] {
            Array(components)
        }

        static func buildOptional(_ component: [EducationalComponent]?) -> [EducationalComponent] {
            component ?? []
        }

        static func buildEither(first component: [EducationalComponent]) -> [EducationalComponent] {
            component
        }

        static func buildEither(second component: [EducationalComponent]) -> [EducationalComponent] {
            component
        }

        static func buildArray(_ components: [[EducationalComponent]]) -> [EducationalComponent] {
            components.flatMap { $0 }
        }

        static func buildExpression(_ expression: EducationalComponent) -> [EducationalComponent] {
            [expression]
        }

        static func buildExpression(_ expression: String) -> [EducationalComponent] {
            [.text(expression)]
        }
    }

    // Define educational components
    enum EducationalComponent {
        case text(String)
        case concept(String, level: String)
        case example(String, language: String)
        case question(String)

        var contentPart: ContentPart {
            switch self {
            case .text(let content):
                return .text(content)
            case .concept(let concept, let level):
                return .text("**Concept (\(level)):** \(concept)")
            case .example(let code, let language):
                return .text("```\(language)\n\(code)\n```")
            case .question(let question):
                return .text("**Question:** \(question)")
            }
        }
    }

    // Helper function to convert educational components to messages
    func createEducationalMessage(@EducationalBuilder content: () -> [EducationalComponent]) -> UserMessage {
        let components = content()
        let combinedContent = components.map { $0.contentPart }
        return UserMessage(content: combinedContent)
    }

    let client = try LLMClient(baseURLString: "https://api.openai.com/v1/responses")

    // Use the specialized builder
    let educationalMessage = createEducationalMessage {
        "Teach me about recursion"
        EducationalComponent.concept("Recursion is when a function calls itself", level: "basic")
        EducationalComponent.example("""
        func factorial(_ n: Int) -> Int {
            if n <= 1 { return 1 }
            return n * factorial(n - 1)
        }
        """, language: "swift")
        EducationalComponent.question("Can you show me another example?")
    }

    let request = try ResponseRequest(
        model: "gpt-4",
        config: {
            Temperature(0.3)
            MaxOutputTokens(300)
        },
        input: {
            system("You are an expert programming tutor. Explain concepts clearly with examples.")
            educationalMessage
        }
    )

    print("üéì Using educational builder...")
    let response = try await client.respond(to: request)

    if let explanation = response.choices.first?.message.content {
        print("ü§ñ Educational response:")
        print("   \(explanation)")
    }

    print("‚úÖ Domain-specific builders demonstrated!")
}

/// Example 3: Custom Message Types
/// Shows how to create specialized message types for specific domains
func customMessageTypesExample() async throws {
    print("\nüìù Custom Message Types")
    print("======================")

    // Define a custom message type for code review
    struct CodeReviewMessage: ResponseMessage {
        let role: Role = .user
        let content: [ContentPart]
        let codeSnippet: String
        let language: String
        let reviewFocus: [String]

        init(code: String, language: String, focus: [String]) {
            self.codeSnippet = code
            self.language = language
            self.reviewFocus = focus

            // Create content with structured review request
            var contentParts: [ContentPart] = []
            contentParts.append(.text("Please review this \(language) code:"))
            contentParts.append(.text("```\(language)\n\(code)\n```"))
            contentParts.append(.text("Focus areas: \(focus.joined(separator: ", "))"))
            contentParts.append(.text("Please provide feedback on:"))
            for area in focus {
                contentParts.append(.text("‚Ä¢ \(area)"))
            }

            self.content = contentParts
        }
    }

    // Define a custom message type for design feedback
    struct DesignFeedbackMessage: ResponseMessage {
        let role: Role = .user
        let content: [ContentPart]
        let designDescription: String
        let targetAudience: String
        let constraints: [String]

        init(design: String, audience: String, constraints: [String]) {
            self.designDescription = design
            self.targetAudience = audience
            self.constraints = constraints

            var contentParts: [ContentPart] = []
            contentParts.append(.text("Please provide design feedback for:"))
            contentParts.append(.text(design))
            contentParts.append(.text("Target audience: \(audience)"))
            contentParts.append(.text("Constraints to consider:"))
            for constraint in constraints {
                contentParts.append(.text("‚Ä¢ \(constraint)"))
            }

            self.content = contentParts
        }
    }

    let client = try LLMClient(baseURLString: "https://api.openai.com/v1/responses")

    // Example 1: Code review
    let codeReview = CodeReviewMessage(
        code: """
        func processData(_ data: [Int]) -> [Int] {
            var result = [Int]()
            for item in data {
                if item > 0 {
                    result.append(item * 2)
                }
            }
            return result
        }
        """,
        language: "swift",
        focus: ["performance", "error handling", "code style"]
    )

    let codeReviewRequest = try ResponseRequest(
        model: "gpt-4",
        input: {
            system("You are a senior software engineer specializing in code reviews.")
            codeReview
        }
    )

    print("üîç Code review request...")
    let codeReviewResponse = try await client.respond(to: codeReviewRequest)

    if let feedback = codeReviewResponse.choices.first?.message.content {
        print("ü§ñ Code review feedback:")
        print("   \(feedback)")
    }

    // Example 2: Design feedback
    let designFeedback = DesignFeedbackMessage(
        design: "A mobile app for tracking daily water intake with gamification elements",
        audience: "Young adults aged 18-35 who want to improve their health habits",
        constraints: ["iOS and Android compatibility", "Offline functionality", "Privacy-focused data handling"]
    )

    let designRequest = try ResponseRequest(
        model: "gpt-4",
        input: {
            system("You are a UX/UI design expert with experience in health and fitness apps.")
            designFeedback
        }
    )

    print("\nüé® Design feedback request...")
    let designResponse = try await client.respond(to: designRequest)

    if let feedback = designResponse.choices.first?.message.content {
        print("ü§ñ Design feedback:")
        print("   \(feedback)")
    }

    print("‚úÖ Custom message types demonstrated!")
}

/// Example 4: Integration with External Services
/// Shows how to integrate with external APIs and services
func externalIntegrationExample() async throws {
    print("\nüîó External Service Integration")
    print("===============================")

    // Simulate integration with an external service
    struct ExternalService {
        static func fetchUserProfile(userId: String) async throws -> [String: Any] {
            // Simulate API call
            try await Task.sleep(nanoseconds: 100_000_000) // 0.1 second delay
            return [
                "name": "John Doe",
                "interests": ["programming", "AI", "Swift"],
                "experience_level": "intermediate"
            ]
        }

        static func searchDocumentation(query: String) async throws -> [String] {
            // Simulate documentation search
            try await Task.sleep(nanoseconds: 150_000_000) // 0.15 second delay
            return [
                "Swift Programming Language Guide",
                "SwiftUI Tutorials",
                "Combine Framework Documentation",
                "Swift Package Manager Guide"
            ]
        }
    }

    // Create custom tools that integrate with external services
    let userProfileTool = Tool(
        type: .function,
        function: Tool.Function(
            name: "get_user_profile",
            description: "Retrieve user profile information",
            parameters: .object([
                "user_id": .string(description: "User identifier")
            ])
        )
    )

    let documentationTool = Tool(
        type: .function,
        function: Tool.Function(
            name: "search_documentation",
            description: "Search for documentation and guides",
            parameters: .object([
                "query": .string(description: "Search query")
            ])
        )
    )

    let client = try LLMClient(baseURLString: "https://api.openai.com/v1/responses")

    // Simulate a complex workflow with external integrations
    var conversation = ResponseConversation()

    conversation.append(system: """
    You are a personalized learning assistant. Use the available tools to:
    1. Get user profile information to understand their background
    2. Search for relevant documentation based on their interests
    3. Provide personalized learning recommendations
    """)

    conversation.append(user: "I want to learn more about Swift. Can you help me get started?")

    // First interaction - AI might use tools
    let initialRequest = try ResponseRequest(
        model: "gpt-4",
        input: conversation.messages,
        tools: [userProfileTool, documentationTool]
    )

    let initialResponse = try await client.respond(to: initialRequest)

    if let toolCalls = initialResponse.outputItems?.filter({ $0.type == .toolCall }) {
        print("üîß AI requested \(toolCalls.count) tool call(s)")

        // Simulate tool execution
        for toolCall in toolCalls {
            if let function = toolCall.toolCall?.function {
                switch function.name {
                case "get_user_profile":
                    print("üìä Fetching user profile...")
                    let profile = try await ExternalService.fetchUserProfile(userId: "user123")
                    conversation.append(tool: ToolMessage(
                        toolCallId: toolCall.toolCall?.id ?? "",
                        content: "User profile: \(profile)"
                    ))

                case "search_documentation":
                    print("üìö Searching documentation...")
                    let docs = try await ExternalService.searchDocumentation(query: "Swift programming")
                    conversation.append(tool: ToolMessage(
                        toolCallId: toolCall.toolCall?.id ?? "",
                        content: "Documentation results: \(docs.joined(separator: ", "))"
                    ))

                default:
                    break
                }
            }
        }

        // Continue conversation with tool results
        let followUpRequest = try ResponseRequest(
            model: "gpt-4",
            input: conversation.messages
        )

        let finalResponse = try await client.respond(to: followUpRequest)

        if let personalizedAdvice = finalResponse.choices.first?.message.content {
            print("ü§ñ Personalized learning plan:")
            print("   \(personalizedAdvice)")
        }

    } else if let directResponse = initialResponse.choices.first?.message.content {
        print("ü§ñ Direct response:")
        print("   \(directResponse)")
    }

    print("‚úÖ External integration demonstrated!")
}

/// Main function to run all custom extension examples
func runCustomExtensionsExamples() async {
    print("‚ö° SwiftResponsesDSL - Custom Extensions")
    print("=====================================")
    print("Learn how to create domain-specific extensions and integrations.\n")

    do {
        try await customParameterTypesExample()
        try await domainSpecificBuildersExample()
        try await customMessageTypesExample()
        try await externalIntegrationExample()

        print("\nüéâ All custom extension examples completed!")
        print("üí° Extensions allow you to tailor SwiftResponsesDSL to your specific domain!")

    } catch {
        print("‚ùå Example failed with error:", error.localizedDescription)
    }
}
