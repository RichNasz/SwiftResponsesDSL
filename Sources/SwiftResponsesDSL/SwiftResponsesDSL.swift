//
//  SwiftResponsesDSL.swift
//  SwiftResponsesDSL
//
//  Generated by AI-assisted code generation.
//  Created by Richard Naszcyniec on [Date].
//  Copyright Â© [Year] Richard Naszcyniec. All rights reserved.
//
//  This file is part of SwiftResponsesDSL.
//  License: [SPDX-License-Identifier: MIT] or see LICENSE file.
//  Generated with: AI Code Generator [Version]
//  Specification: SwiftResponsesDSL v1.0 ([Spec Date])
//  Generation ID: [Unique ID for tracking]
//
//  === CODE GENERATION INFO ===
//  Generated with: AI Code Generator v1.0
//  Specification: SwiftResponsesDSL v1.0
//  Generation ID: swift-dsl-gen-2024-001
//
//  === MODIFICATION POLICY ===
//  This file was automatically generated. While modifications are allowed
//  for debugging, customization, or extension purposes, please:
//
//  1. Update the modification history below
//  2. Preserve the original generation metadata
//  3. Consider regenerating from source when possible
//  4. Document significant changes in comments
//
//  === MODIFICATION HISTORY ===
//  [Date] - [Modifier] - [Change Description]
//  - Initial Generation - AI-generated from SwiftResponsesDSL spec v1.0
//
//  Last Modified: [Date]
//  Modified By: Richard Naszcyniec
//

import Foundation

// MARK: - Core Enums

/// Defines message roles in the conversation
public enum Role: String, Codable, Sendable {
    case system
    case user
    case assistant
    case tool
}

/// Comprehensive error handling for LLM operations
public enum LLMError: Error, LocalizedError, Equatable, Sendable {
    case invalidURL
    case encodingFailed(String)
    case networkError(String)
    case decodingFailed(String)
    case serverError(statusCode: Int, message: String?)
    case rateLimit
    case invalidResponse
    case invalidValue(String)
    case missingRequiredField
    case missingBaseURL
    case missingModel
    case authenticationFailed
    case timeout
    case sslError(String)
    case httpError(statusCode: Int, message: String?)
    case jsonParsingError(String)
    case invalidParameter(String, String)

    public var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "The provided URL is invalid"
        case .encodingFailed(let msg):
            return "Failed to encode data: \(msg)"
        case .networkError(let msg):
            return "Network operation failed: \(msg)"
        case .decodingFailed(let msg):
            return "Failed to decode data: \(msg)"
        case .serverError(let code, let msg):
            return "Server error (\(code)): \(msg ?? "Unknown error")"
        case .rateLimit:
            return "Rate limit exceeded"
        case .invalidResponse:
            return "Received invalid response"
        case .invalidValue(let msg):
            return "Invalid value: \(msg)"
        case .missingRequiredField:
            return "Required field is missing"
        case .missingBaseURL:
            return "Base URL is required but not provided"
        case .missingModel:
            return "Model is required but not provided"
        case .authenticationFailed:
            return "Authentication failed"
        case .timeout:
            return "Request timed out"
        case .sslError(let msg):
            return "SSL/TLS error: \(msg)"
        case .httpError(let code, let msg):
            return "HTTP error (\(code)): \(msg ?? "Unknown error")"
        case .jsonParsingError(let msg):
            return "JSON parsing error: \(msg)"
        case .invalidParameter(let param, let reason):
            return "Invalid parameter '\(param)': \(reason)"
        }
    }

    public var recoverySuggestion: String? {
        switch self {
        case .rateLimit:
            return "Please wait before retrying the request"
        case .timeout:
            return "Check network connectivity and try again"
        case .networkError:
            return "Verify network settings and try again"
        default:
            return nil
        }
    }
}

/// Represents multimodal content (text, image URLs, files)
public enum ContentPart: Codable, Sendable {
    case text(String)
    case imageUrl(url: String, detail: Detail? = nil)
    case inputFile(fileId: String)
    case inputFileData(dataUrl: String)

    public enum Detail: String, Codable, Sendable {
        case auto
        case low
        case high
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .text(let content):
            try container.encode("text", forKey: .type)
            try container.encode(content, forKey: .text)
        case .imageUrl(let url, let detail):
            try container.encode("image_url", forKey: .type)
            var imageUrlContainer = container.nestedContainer(keyedBy: ImageUrlKeys.self, forKey: .imageUrl)
            try imageUrlContainer.encode(url, forKey: .url)
            if let detail = detail {
                try imageUrlContainer.encode(detail, forKey: .detail)
            }
        case .inputFile(let fileId):
            try container.encode("input_file", forKey: .type)
            try container.encode(fileId, forKey: .fileId)
        case .inputFileData(let dataUrl):
            try container.encode("input_file_data", forKey: .type)
            try container.encode(dataUrl, forKey: .fileData)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "text":
            let text = try container.decode(String.self, forKey: .text)
            self = .text(text)
        case "image_url":
            let imageUrlContainer = try container.nestedContainer(keyedBy: ImageUrlKeys.self, forKey: .imageUrl)
            let url = try imageUrlContainer.decode(String.self, forKey: .url)
            let detail = try imageUrlContainer.decodeIfPresent(Detail.self, forKey: .detail)
            self = .imageUrl(url: url, detail: detail)
        case "input_file":
            let fileId = try container.decode(String.self, forKey: .fileId)
            self = .inputFile(fileId: fileId)
        case "input_file_data":
            let dataUrl = try container.decode(String.self, forKey: .fileData)
            self = .inputFileData(dataUrl: dataUrl)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown content part type: \(type)")
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type, text, imageUrl = "image_url", fileId, fileData
    }

    private enum ImageUrlKeys: String, CodingKey {
        case url, detail
    }
}

/// Represents annotations in response text (citations, etc.)
public enum Annotation: Decodable, Sendable {
    case urlCitation(startIndex: Int, endIndex: Int, url: String, title: String)
    case fileCitation(index: Int, fileId: String, filename: String)
    case unknown(type: String, data: [String: AnyCodable])

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "url_citation":
            let startIndex = try container.decode(Int.self, forKey: .startIndex)
            let endIndex = try container.decode(Int.self, forKey: .endIndex)
            let url = try container.decode(String.self, forKey: .url)
            let title = try container.decode(String.self, forKey: .title)
            self = .urlCitation(startIndex: startIndex, endIndex: endIndex, url: url, title: title)
        case "file_citation":
            let index = try container.decode(Int.self, forKey: .index)
            let fileId = try container.decode(String.self, forKey: .fileId)
            let filename = try container.decode(String.self, forKey: .filename)
            self = .fileCitation(index: index, fileId: fileId, filename: filename)
        default:
            let data = try container.decode([String: AnyCodable].self, forKey: .data)
            self = .unknown(type: type, data: data)
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type, startIndex = "start_index", endIndex = "end_index", url, title, index, fileId = "file_id", filename, data
    }
}

// MARK: - Type-Erased Codable

/// Type-erased Codable for flexible JSON fields (e.g., metadata, error)
public enum AnyCodable: Codable, Sendable {
    case null
    case bool(Bool)
    case int(Int)
    case double(Double)
    case string(String)
    case array([AnyCodable])
    case dictionary([String: AnyCodable])

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .null:
            try container.encodeNil()
        case .bool(let value):
            try container.encode(value)
        case .int(let value):
            try container.encode(value)
        case .double(let value):
            try container.encode(value)
        case .string(let value):
            try container.encode(value)
        case .array(let value):
            try container.encode(value)
        case .dictionary(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if container.decodeNil() {
            self = .null
        } else if let value = try? container.decode(Bool.self) {
            self = .bool(value)
        } else if let value = try? container.decode(Int.self) {
            self = .int(value)
        } else if let value = try? container.decode(Double.self) {
            self = .double(value)
        } else if let value = try? container.decode(String.self) {
            self = .string(value)
        } else if let value = try? container.decode([AnyCodable].self) {
            self = .array(value)
        } else if let value = try? container.decode([String: AnyCodable].self) {
            self = .dictionary(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "AnyCodable value cannot be decoded")
        }
    }

    // Convenience accessors
    public var intValue: Int? {
        if case .int(let value) = self { return value }
        return nil
    }

    public var stringValue: String? {
        if case .string(let value) = self { return value }
        return nil
    }

    public var boolValue: Bool? {
        if case .bool(let value) = self { return value }
        return nil
    }

    public var doubleValue: Double? {
        if case .double(let value) = self { return value }
        return nil
    }

    // Static constructor for converting from Any
    public static func fromAny(_ value: Any) -> AnyCodable? {
        switch value {
        case let v as Bool:
            return .bool(v)
        case let v as Int:
            return .int(v)
        case let v as Double:
            return .double(v)
        case let v as String:
            return .string(v)
        case let v as [Any]:
            let array = v.compactMap { fromAny($0) }
            return .array(array)
        case let v as [String: Any]:
            let dict = v.compactMapValues { fromAny($0) }
            return .dictionary(dict)
        case _ as NSNull:
            return .null
        default:
            return nil
        }
    }
}

// MARK: - Protocols

/// Defines messages with a role and multimodal content
public protocol ResponseMessage: Encodable, Sendable {
    var role: Role { get }
    var content: [ContentPart] { get }
}

/// Protocol for configuration parameter structs that can modify requests
public protocol ResponseConfigParameter: Sendable {
    func apply(to request: inout ResponseRequest) throws
}

// MARK: - Message Types

/// Represents system prompts
public struct SystemMessage: ResponseMessage {
    public let role: Role = .system
    public let content: [ContentPart]

    public init(text: String) {
        self.content = [.text(text)]
    }

    public init(content: [ContentPart]) {
        self.content = content
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(role, forKey: .role)
        try container.encode(content, forKey: .content)
    }

    private enum CodingKeys: String, CodingKey {
        case role, content
    }
}

/// Represents user or tool messages with multimodal content
public struct UserMessage: ResponseMessage {
    public let role: Role
    public let content: [ContentPart]

    public init(role: Role = .user, content: [ContentPart]) {
        self.role = role
        self.content = content
    }

    public init(role: Role = .user, text: String) {
        self.role = role
        self.content = [.text(text)]
    }

    public init(role: Role = .user, fileId: String) {
        self.role = role
        self.content = [.inputFile(fileId: fileId)]
    }

    public init(role: Role = .user, base64File: String, mimeType: String = "application/pdf") {
        self.role = role
        self.content = [.inputFileData(dataUrl: "data:\(mimeType);base64,\(base64File)")]
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(role, forKey: .role)
        try container.encode(content, forKey: .content)
    }

    private enum CodingKeys: String, CodingKey {
        case role, content
    }
}

/// Represents assistant responses in conversation history
public struct AssistantMessage: ResponseMessage, Decodable {
    public let role: Role = .assistant
    public let content: [ContentPart]

    public init(text: String) {
        self.content = [.text(text)]
    }

    public init(content: [ContentPart]) {
        self.content = content
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let decodedRole = try container.decode(Role.self, forKey: .role)
        guard decodedRole == .assistant else {
            throw DecodingError.dataCorruptedError(forKey: .role, in: container, debugDescription: "Expected assistant role")
        }
        self.content = try container.decode([ContentPart].self, forKey: .content)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(role, forKey: .role)
        try container.encode(content, forKey: .content)
    }

    private enum CodingKeys: String, CodingKey {
        case role, content
    }
}

// MARK: - Tool Definitions

/// Defines tools (e.g., function, file_search, web_search_preview) with configurations
public struct Tool: Codable, Sendable {
    public let type: String
    public let function: Function?
    public let fileSearch: FileSearch?
    public let webSearchPreview: WebSearchPreview?

    public enum CodingKeys: String, CodingKey {
        case type, function
        case fileSearch = "file_search"
        case webSearchPreview = "web_search_preview"
    }

    public struct Function: Codable, Sendable {
        public let name: String
        public let description: String?
        public let parameters: [String: AnyCodable]
        public let strict: Bool?

        public enum CodingKeys: String, CodingKey {
            case name, description, parameters, strict
        }
    }

    public struct FileSearch: Codable, Sendable {
        public let filters: [String: AnyCodable]?
        public let maxNumResults: Int?
        public let rankingOptions: RankingOptions?
        public let vectorStoreIds: [String]?

        public enum CodingKeys: String, CodingKey {
            case filters
            case maxNumResults = "max_num_results"
            case rankingOptions = "ranking_options"
            case vectorStoreIds = "vector_store_ids"
        }

        public struct RankingOptions: Codable, Sendable {
            public let ranker: String
            public let scoreThreshold: Double

            public enum CodingKeys: String, CodingKey {
                case ranker
                case scoreThreshold = "score_threshold"
            }
        }
    }

    public struct WebSearchPreview: Codable, Sendable {
        public let domains: [String]
        public let searchContextSize: String
        public let userLocation: UserLocation?

        public enum CodingKeys: String, CodingKey {
            case domains
            case searchContextSize = "search_context_size"
            case userLocation = "user_location"
        }

        public struct UserLocation: Codable, Sendable {
            public let type: String
            public let city: String?
            public let country: String?
            public let region: String?
            public let timezone: String?

            public enum CodingKeys: String, CodingKey {
                case type, city, country, region, timezone
            }
        }
    }
}

// MARK: - Configuration Parameter Structs

/// Controls randomness in responses (0.0 to 2.0)
public struct Temperature: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (0.0...2.0).contains(value) else {
            throw LLMError.invalidValue("Temperature must be between 0.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.temperature = value
    }
}

/// Controls diversity via nucleus sampling (0.0 to 1.0)
public struct TopP: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (0.0...1.0).contains(value) else {
            throw LLMError.invalidValue("TopP must be between 0.0 and 1.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.topP = value
    }
}

/// Maximum number of tokens to generate (positive integer)
public struct MaxOutputTokens: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard value > 0 else {
            throw LLMError.invalidValue("MaxOutputTokens must be positive")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.maxOutputTokens = value
    }
}

/// Reduces likelihood of repeating tokens (-2.0 to 2.0)
public struct FrequencyPenalty: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (-2.0...2.0).contains(value) else {
            throw LLMError.invalidValue("FrequencyPenalty must be between -2.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.frequencyPenalty = value
    }
}

/// Reduces likelihood of repeating topics (-2.0 to 2.0)
public struct PresencePenalty: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (-2.0...2.0).contains(value) else {
            throw LLMError.invalidValue("PresencePenalty must be between -2.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.presencePenalty = value
    }
}

/// Maximum number of tool calls allowed (1 to 128)
public struct MaxToolCalls: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard (1...128).contains(value) else {
            throw LLMError.invalidValue("MaxToolCalls must be between 1 and 128")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.maxToolCalls = value
    }
}

/// Controls tool usage behavior
public struct ToolChoice: ResponseConfigParameter {
    public let value: String
    public init(_ value: String) throws {
        let validChoices = ["none", "auto", "required"]
        guard validChoices.contains(value) else {
            throw LLMError.invalidValue("ToolChoice must be one of: \(validChoices.joined(separator: ", "))")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.toolChoice = value
    }
}

/// Number of top log probabilities to return (0 to 20)
public struct TopLogprobs: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard (0...20).contains(value) else {
            throw LLMError.invalidValue("TopLogprobs must be between 0 and 20")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.topLogprobs = value
    }
}

/// Random seed for reproducible outputs (non-negative integer)
public struct Seed: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard value >= 0 else {
            throw LLMError.invalidValue("Seed must be non-negative")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.seed = value
    }
}

/// Defines available tools for the model
public struct Tools: ResponseConfigParameter {
    public let value: [Tool]
    public init(_ value: [Tool]) throws {
        guard !value.isEmpty else {
            throw LLMError.invalidValue("Tools array cannot be empty")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.tools = value
    }
}

/// Enables parallel tool calls
public struct ParallelToolCalls: ResponseConfigParameter {
    public let value: Bool
    public init(_ value: Bool) {
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.parallelToolCalls = value
    }
}

/// Streaming options configuration
public struct StreamOptions: ResponseConfigParameter {
    public let value: [String: AnyCodable]
    public init(_ value: [String: AnyCodable]) {
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.streamOptions = value
    }
}

// MARK: - Core Request and Response Types

/// Represents a request to the LLM API
public struct ResponseRequest: Encodable, Sendable {
    public var model: String
    public var messages: [any ResponseMessage]
    public var stream: Bool
    public var previousResponseId: String?
    public var temperature: Double?
    public var topP: Double?
    public var maxOutputTokens: Int?
    public var toolChoice: String?
    public var tools: [Tool]?
    public var parallelToolCalls: Bool?
    public var frequencyPenalty: Double?
    public var presencePenalty: Double?
    public var logitBias: [Int: Int]?
    public var user: String?
    public var stop: [String]?
    public var seed: Int?
    public var responseFormat: [String: AnyCodable]?
    public var logprobs: Bool?
    public var topLogprobs: Int?
    public var streamOptions: [String: AnyCodable]?
    public var truncation: String?
    public var store: Bool?
    public var background: Bool?
    public var maxToolCalls: Int?
    public var serviceTier: String?

    public enum CodingKeys: String, CodingKey {
        case model, messages, stream
        case previousResponseId = "previous_response_id"
        case temperature, topP = "top_p"
        case maxOutputTokens = "max_output_tokens"
        case toolChoice = "tool_choice"
        case tools
        case parallelToolCalls = "parallel_tool_calls"
        case frequencyPenalty = "frequency_penalty"
        case presencePenalty = "presence_penalty"
        case logitBias = "logit_bias"
        case user, stop, seed
        case responseFormat = "response_format"
        case logprobs
        case topLogprobs = "top_logprobs"
        case streamOptions = "stream_options"
        case truncation, store, background
        case maxToolCalls = "max_tool_calls"
        case serviceTier = "service_tier"
    }

    public init(model: String, input: [any ResponseMessage], previousResponseId: String? = nil, stream: Bool = false, config: [any ResponseConfigParameter]) throws {
        self.model = model
        self.messages = input
        self.stream = stream
        self.previousResponseId = previousResponseId

        // Initialize all optional properties to nil
        self.temperature = nil
        self.topP = nil
        self.maxOutputTokens = nil
        self.toolChoice = nil
        self.tools = nil
        self.parallelToolCalls = nil
        self.frequencyPenalty = nil
        self.presencePenalty = nil
        self.logitBias = nil
        self.user = nil
        self.stop = nil
        self.seed = nil
        self.responseFormat = nil
        self.logprobs = nil
        self.topLogprobs = nil
        self.streamOptions = nil
        self.truncation = nil
        self.store = nil
        self.background = nil
        self.maxToolCalls = nil
        self.serviceTier = nil

        // Apply configuration parameters
        var mutableSelf = self
        for param in config {
            try param.apply(to: &mutableSelf)
        }
        self = mutableSelf
    }

    public init(model: String, previousResponseId: String? = nil, stream: Bool = false, @ResponseConfigBuilder config: () throws -> [any ResponseConfigParameter], @ResponseBuilder input: () -> [any ResponseMessage]) throws {
        try self.init(model: model, input: input(), previousResponseId: previousResponseId, stream: stream, config: config())
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(model, forKey: .model)
        try container.encode(stream, forKey: .stream)

        if let previousResponseId = previousResponseId {
            try container.encode(previousResponseId, forKey: .previousResponseId)
        }

        // Encode messages with type erasure handling
        var messagesContainer = container.nestedUnkeyedContainer(forKey: .messages)
        for message in messages {
            if let systemMessage = message as? SystemMessage {
                try messagesContainer.encode(systemMessage)
            } else if let userMessage = message as? UserMessage {
                try messagesContainer.encode(userMessage)
            } else if let assistantMessage = message as? AssistantMessage {
                try messagesContainer.encode(assistantMessage)
            }
        }

        // Encode optional properties only if they have values
        if let temperature = temperature {
            try container.encode(temperature, forKey: .temperature)
        }
        if let topP = topP {
            try container.encode(topP, forKey: .topP)
        }
        if let maxOutputTokens = maxOutputTokens {
            try container.encode(maxOutputTokens, forKey: .maxOutputTokens)
        }
        if let toolChoice = toolChoice {
            try container.encode(toolChoice, forKey: .toolChoice)
        }
        if let tools = tools {
            try container.encode(tools, forKey: .tools)
        }
        if let parallelToolCalls = parallelToolCalls {
            try container.encode(parallelToolCalls, forKey: .parallelToolCalls)
        }
        if let frequencyPenalty = frequencyPenalty {
            try container.encode(frequencyPenalty, forKey: .frequencyPenalty)
        }
        if let presencePenalty = presencePenalty {
            try container.encode(presencePenalty, forKey: .presencePenalty)
        }
        if let logitBias = logitBias {
            try container.encode(logitBias, forKey: .logitBias)
        }
        if let user = user {
            try container.encode(user, forKey: .user)
        }
        if let stop = stop {
            try container.encode(stop, forKey: .stop)
        }
        if let seed = seed {
            try container.encode(seed, forKey: .seed)
        }
        if let responseFormat = responseFormat {
            try container.encode(responseFormat, forKey: .responseFormat)
        }
        if let logprobs = logprobs {
            try container.encode(logprobs, forKey: .logprobs)
        }
        if let topLogprobs = topLogprobs {
            try container.encode(topLogprobs, forKey: .topLogprobs)
        }
        if let streamOptions = streamOptions {
            try container.encode(streamOptions, forKey: .streamOptions)
        }
        if let truncation = truncation {
            try container.encode(truncation, forKey: .truncation)
        }
        if let store = store {
            try container.encode(store, forKey: .store)
        }
        if let background = background {
            try container.encode(background, forKey: .background)
        }
        if let maxToolCalls = maxToolCalls {
            try container.encode(maxToolCalls, forKey: .maxToolCalls)
        }
        if let serviceTier = serviceTier {
            try container.encode(serviceTier, forKey: .serviceTier)
        }
    }
}

// MARK: - Result Builders

/// Result builder for creating message arrays
@resultBuilder
public struct ResponseBuilder {
    public static func buildBlock(_ components: (any ResponseMessage)...) -> [any ResponseMessage] {
        Array(components)
    }

    public static func buildOptional(_ component: [any ResponseMessage]?) -> [any ResponseMessage] {
        component ?? []
    }

    public static func buildEither(first component: [any ResponseMessage]) -> [any ResponseMessage] {
        component
    }

    public static func buildEither(second component: [any ResponseMessage]) -> [any ResponseMessage] {
        component
    }

    public static func buildArray(_ components: [[any ResponseMessage]]) -> [any ResponseMessage] {
        components.flatMap { $0 }
    }

    public static func buildExpression(_ expression: any ResponseMessage) -> [any ResponseMessage] {
        [expression]
    }

    public static func buildExpression(_ expression: String) -> [any ResponseMessage] {
        [UserMessage(text: expression)]
    }

    public static func buildExpression(_ expression: [any ResponseMessage]) -> [any ResponseMessage] {
        expression
    }

    public static func buildLimitedAvailability(_ component: [any ResponseMessage]) -> [any ResponseMessage] {
        component
    }

    public static func buildFinalResult(_ component: [any ResponseMessage]) -> [any ResponseMessage] {
        component
    }
}

/// Result builder for creating configuration parameter arrays
@resultBuilder
public struct ResponseConfigBuilder {
    public static func buildBlock(_ components: (any ResponseConfigParameter)...) -> [any ResponseConfigParameter] {
        Array(components)
    }

    public static func buildOptional(_ component: [any ResponseConfigParameter]?) -> [any ResponseConfigParameter] {
        component ?? []
    }

    public static func buildEither(first component: [any ResponseConfigParameter]) -> [any ResponseConfigParameter] {
        component
    }

    public static func buildEither(second component: [any ResponseConfigParameter]) -> [any ResponseConfigParameter] {
        component
    }

    public static func buildArray(_ components: [[any ResponseConfigParameter]]) -> [any ResponseConfigParameter] {
        components.flatMap { $0 }
    }

    public static func buildExpression(_ expression: any ResponseConfigParameter) -> [any ResponseConfigParameter] {
        [expression]
    }

    public static func buildLimitedAvailability(_ component: [any ResponseConfigParameter]) -> [any ResponseConfigParameter] {
        component
    }

    public static func buildFinalResult(_ component: [any ResponseConfigParameter]) -> [any ResponseConfigParameter] {
        component
    }
}

// MARK: - Conversation Management

/// Manages conversation history for multi-turn interactions
public struct ResponseConversation: Sendable {
    public private(set) var messages: [any ResponseMessage]
    public var previousResponseId: String?

    public init(messages: [any ResponseMessage] = []) {
        self.messages = messages
    }

    public mutating func append(_ message: any ResponseMessage) {
        messages.append(message)
    }

    public mutating func append(system text: String) {
        messages.append(SystemMessage(text: text))
    }

    public mutating func append(user text: String) {
        messages.append(UserMessage(text: text))
    }

    public mutating func append(user content: [ContentPart]) {
        messages.append(UserMessage(content: content))
    }

    public mutating func append(assistant text: String) {
        messages.append(AssistantMessage(text: text))
    }

    public mutating func append(assistant content: [ContentPart]) {
        messages.append(AssistantMessage(content: content))
    }

    public mutating func append(response: Response) {
        // Add assistant message from response
        if let assistantMessage = response.assistantMessages.first {
            messages.append(assistantMessage)
        }

        // Add tool calls if any
        for _ in response.toolCalls {
            // Create a tool message based on the tool call
            // This would need to be implemented based on the specific tool call structure
        }

        // Update previous response ID for server-side state
        previousResponseId = response.id
    }

    public func generateRequest(model: String, stream: Bool = false, config: [any ResponseConfigParameter] = []) throws -> ResponseRequest {
        try ResponseRequest(model: model, input: messages, previousResponseId: previousResponseId, stream: stream, config: config)
    }
}

// MARK: - Response Types

/// Represents a response from the LLM API
public struct Response: Decodable, Sendable {
    public let id: String
    public let object: String
    public let created: Int
    public let model: String
    public let choices: [Choice]
    public let usage: Usage?
    public let systemFingerprint: String?
    public let serviceTier: String?

    public enum CodingKeys: String, CodingKey {
        case id, object, created, model, choices, usage
        case systemFingerprint = "system_fingerprint"
        case serviceTier = "service_tier"
    }

    /// A choice in the response
    public struct Choice: Decodable, Sendable {
        public let index: Int
        public let message: AssistantMessage?
        public let finishReason: String?
        public let logprobs: Logprobs?

        public enum CodingKeys: String, CodingKey {
            case index, message
            case finishReason = "finish_reason"
            case logprobs
        }

        /// Log probability information
        public struct Logprobs: Decodable, Sendable {
            public let content: [ContentLogprob]?
        }

        /// Log probability for content tokens
        public struct ContentLogprob: Decodable, Sendable {
            public let token: String
            public let logprob: Double
            public let bytes: [Int]?
            public let topLogprobs: [TopLogprob]?

            public enum CodingKeys: String, CodingKey {
                case token, logprob, bytes
                case topLogprobs = "top_logprobs"
            }

            public struct TopLogprob: Decodable, Sendable {
                public let token: String
                public let logprob: Double
                public let bytes: [Int]?
            }
        }
    }

    /// Token usage information
    public struct Usage: Decodable, Sendable {
        public let promptTokens: Int
        public let completionTokens: Int?
        public let totalTokens: Int
        public let completionTokensDetails: CompletionTokensDetails?
        public let promptTokensDetails: PromptTokensDetails?

        public enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
            case completionTokensDetails = "completion_tokens_details"
            case promptTokensDetails = "prompt_tokens_details"
        }

        public struct CompletionTokensDetails: Decodable, Sendable {
            public let reasoningTokens: Int?
            public let acceptedPredictionTokens: Int?
            public let rejectedPredictionTokens: Int?

            public enum CodingKeys: String, CodingKey {
                case reasoningTokens = "reasoning_tokens"
                case acceptedPredictionTokens = "accepted_prediction_tokens"
                case rejectedPredictionTokens = "rejected_prediction_tokens"
            }
        }

        public struct PromptTokensDetails: Decodable, Sendable {
            public let cachedTokens: Int?

            public enum CodingKeys: String, CodingKey {
                case cachedTokens = "cached_tokens"
            }
        }
    }

    // MARK: - Computed Properties

    /// Extracts all assistant messages from the response
    public var assistantMessages: [AssistantMessage] {
        choices.compactMap { $0.message }
    }

    /// Extracts all tool calls from the response
    public var toolCalls: [OutputItem] {
        let calls: [OutputItem] = []
        for choice in choices {
            if let message = choice.message {
                // Extract tool calls from message content
                for contentPart in message.content {
                    if case .text(_) = contentPart {
                        // Parse tool calls from text if present
                        // This would need more sophisticated parsing
                    }
                }
            }
        }
        return calls
    }
}

// MARK: - Output Items

/// Represents different types of output items in responses
public enum OutputItem: Decodable, Sendable {
    case message(AssistantMessage)
    case toolCall(FunctionCall)
    case fileSearchCall(FileSearchCall)
    case webSearchCall(WebSearchCall)

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)

        switch type {
        case "message":
            let message = try container.decode(AssistantMessage.self, forKey: .message)
            self = .message(message)
        case "tool_call":
            let toolCall = try container.decode(FunctionCall.self, forKey: .toolCall)
            self = .toolCall(toolCall)
        case "file_search_call":
            let fileSearchCall = try container.decode(FileSearchCall.self, forKey: .fileSearchCall)
            self = .fileSearchCall(fileSearchCall)
        case "web_search_call":
            let webSearchCall = try container.decode(WebSearchCall.self, forKey: .webSearchCall)
            self = .webSearchCall(webSearchCall)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown output item type: \(type)")
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type, message, toolCall = "tool_call", fileSearchCall = "file_search_call", webSearchCall = "web_search_call"
    }

    /// Function call output item
    public struct FunctionCall: Decodable, Sendable {
        public let id: String
        public let function: Function

        public enum CodingKeys: String, CodingKey {
            case id, function
        }

        public struct Function: Decodable, Sendable {
            public let name: String
            public let arguments: String
        }
    }

    /// File search call output item
    public struct FileSearchCall: Decodable, Sendable {
        public let id: String
        public let queries: [String]

        public enum CodingKeys: String, CodingKey {
            case id, queries
        }
    }

    /// Web search call output item
    public struct WebSearchCall: Decodable, Sendable {
        public let id: String
        public let searchQuery: String

        public enum CodingKeys: String, CodingKey {
            case id
            case searchQuery = "search_query"
        }
    }
}

// MARK: - Streaming Events

/// Represents events in a streaming response
public enum ResponseEvent: Sendable {
    case created
    case inProgress
    case completed(Response)
    case outputItemAdded(OutputItem)
    case unknown(String, [String: AnyCodable])
}

// MARK: - LLM Client

/// Main client for interacting with LLM APIs
@available(macOS 12.0, iOS 15.0, *)
public actor LLMClient {
    public let baseURL: URL
    private let session: URLSession

    public init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }

    public init(baseURLString: String) throws {
        guard let url = URL(string: baseURLString) else {
            throw LLMError.invalidURL
        }
        self.baseURL = url
        self.session = .shared
    }

    /// Send a request and get a response
    public func respond(to request: ResponseRequest) async throws -> Response {
        let url = baseURL

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(request)

        let (data, response) = try await session.data(for: urlRequest)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw LLMError.networkError("Invalid response type")
        }

        switch httpResponse.statusCode {
        case 200...299:
            let decoder = JSONDecoder()
            return try decoder.decode(Response.self, from: data)
        case 400...499:
            if let errorMessage = String(data: data, encoding: .utf8) {
                throw LLMError.httpError(statusCode: httpResponse.statusCode, message: errorMessage)
            } else {
                throw LLMError.httpError(statusCode: httpResponse.statusCode, message: nil)
            }
        case 500...599:
            throw LLMError.serverError(statusCode: httpResponse.statusCode, message: nil)
        default:
            throw LLMError.invalidResponse
        }
    }

    /// Stream a response
    public func stream(request: ResponseRequest) -> AsyncThrowingStream<ResponseEvent, Error> {
        AsyncThrowingStream { continuation in
            Task {
                do {
                    try await performStreaming(request: request, continuation: continuation)
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }

    private func performStreaming(request: ResponseRequest, continuation: AsyncThrowingStream<ResponseEvent, Error>.Continuation) async throws {
        var streamingRequest = request
        streamingRequest.stream = true

        let url = baseURL
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(streamingRequest)

        let (bytes, response) = try await session.bytes(for: urlRequest)

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw LLMError.invalidResponse
        }

        for try await line in bytes.lines {
            if line.hasPrefix("data: ") {
                let data = String(line.dropFirst(6))
                if data == "[DONE]" {
                    continuation.finish()
                    return
                }

                if let event = parseSSEEvent(data) {
                    continuation.yield(event)
                }
            }
        }
    }

    private func parseSSEEvent(_ data: String) -> ResponseEvent? {
        guard let data = data.data(using: .utf8) else { return nil }

        let decoder = JSONDecoder()
        do {
            let response = try decoder.decode(Response.self, from: data)
            return .completed(response)
        } catch {
            // Try to parse as a partial response or event
            do {
                if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
                   let eventType = json["event"] as? String {
                    switch eventType {
                    case "created":
                        return .created
                    case "in_progress":
                        return .inProgress
                    case "output_item.added":
                        if json["output_item"] is [String: Any] {
                            // Parse output item - simplified for now
                            return .outputItemAdded(.message(AssistantMessage(text: "")))
                        }
                    default:
                        let codableDict = json.reduce(into: [String: AnyCodable]()) { result, pair in
                            if let codable = AnyCodable.fromAny(pair.value) {
                                result[pair.key] = codable
                            }
                        }
                        return .unknown(eventType, codableDict)
                    }
                }
            } catch {
                return nil
            }
        }
        return nil
    }

    /// Convenience method for simple chat interactions
    public func chat(model: String, message: String, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let request = try ResponseRequest(model: model, input: [UserMessage(text: message)], previousResponseId: nil, stream: false, config: config)
        return try await respond(to: request)
    }

    /// Convenience method for chat with system prompt
    public func chat(model: String, systemPrompt: String, message: String, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let messages: [any ResponseMessage] = [SystemMessage(text: systemPrompt), UserMessage(text: message)]
        let request = try ResponseRequest(model: model, input: messages, previousResponseId: nil, stream: false, config: config)
        return try await respond(to: request)
    }

    /// Convenience method for conversation-based chat
    public func chat(conversation: ResponseConversation, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let request = try conversation.generateRequest(model: "", stream: false, config: config)
        return try await respond(to: request)
    }
}

// MARK: - Convenience Functions

/// Creates a system message
public func system(_ text: String) -> SystemMessage {
    SystemMessage(text: text)
}

/// Creates a user message
public func user(_ text: String) -> UserMessage {
    UserMessage(text: text)
}

/// Creates a user message with file
public func user(_ text: String, fileId: String) -> UserMessage {
    UserMessage(role: .user, content: [.text(text), .inputFile(fileId: fileId)])
}

/// Creates an assistant message
public func assistant(_ text: String) -> AssistantMessage {
    AssistantMessage(text: text)
}

/// Creates a tool message
public func tool(_ text: String) -> UserMessage {
    UserMessage(role: .tool, text: text)
}
