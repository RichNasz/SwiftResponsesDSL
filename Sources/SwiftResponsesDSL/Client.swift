//
//  Client.swift
//  SwiftResponsesDSL
//
//  LLMClient actor and networking functionality
//
//  Generated by AI-assisted code generation.
//  Created by Richard Naszcyniec on [Date].
//  Copyright Â© [Year] Richard Naszcyniec. All rights reserved.
//

import Foundation

/// Main client for interacting with LLM APIs
@available(macOS 12.0, iOS 15.0, *)
public actor LLMClient {
    public let baseURL: URL
    private let session: URLSession
    private let apiKey: String?
    private let hasAuth: Bool

    /// Initialize client with URL and optional API key
    /// - Parameters:
    ///   - baseURL: The base URL for the LLM API
    ///   - apiKey: Optional API key for authentication
    ///   - session: URLSession to use (defaults to shared)
    public init(baseURL: URL, apiKey: String? = nil, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.apiKey = apiKey
        self.hasAuth = apiKey != nil
        self.session = session
    }

    /// Initialize client with URL string and API key
    /// - Parameters:
    ///   - baseURLString: String representation of the base URL
    ///   - apiKey: API key for authentication (required for most LLM APIs)
    /// - Throws: `LLMError.invalidURL` if the URL string is invalid
    public init(baseURLString: String, apiKey: String) throws {
        guard let url = URL(string: baseURLString) else {
            throw LLMError.invalidURL
        }
        self.baseURL = url
        self.apiKey = apiKey
        self.hasAuth = true
        self.session = .shared
    }

    /// Initialize client with URL string (for testing or authenticated environments)
    /// - Parameters:
    ///   - baseURLString: String representation of the base URL
    /// - Throws: `LLMError.invalidURL` if the URL string is invalid
    /// - Note: Use this initializer when authentication is handled externally
    public init(baseURLString: String) throws {
        guard let url = URL(string: baseURLString) else {
            throw LLMError.invalidURL
        }
        self.baseURL = url
        self.apiKey = nil
        self.hasAuth = false
        self.session = .shared
    }

    /// Check if the client has authentication configured
    public nonisolated var hasAuthentication: Bool {
        hasAuth
    }

    /// Validate that authentication is properly configured
    /// - Throws: `LLMError.authenticationFailed` if no API key is configured
    public nonisolated func validateAuthentication() throws {
        guard hasAuthentication else {
            throw LLMError.authenticationFailed
        }
    }

    /// Send a request and get a response
    public func respond(to request: ResponseRequest) async throws -> Response {
        let url = baseURL

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Add authentication header if API key is provided
        if let apiKey = apiKey {
            urlRequest.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        }

        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(request)

        let (data, response) = try await session.data(for: urlRequest)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw LLMError.networkError("Invalid response type")
        }

        switch httpResponse.statusCode {
        case 200...299:
            let decoder = JSONDecoder()
            return try decoder.decode(Response.self, from: data)
        case 400...499:
            if let errorMessage = String(data: data, encoding: .utf8) {
                throw LLMError.httpError(statusCode: httpResponse.statusCode, message: errorMessage)
            } else {
                throw LLMError.httpError(statusCode: httpResponse.statusCode, message: nil)
            }
        case 500...599:
            throw LLMError.serverError(statusCode: httpResponse.statusCode, message: nil)
        default:
            throw LLMError.invalidResponse
        }
    }

    /// Stream a response
    public func stream(request: ResponseRequest) -> AsyncThrowingStream<ResponseEvent, Error> {
        AsyncThrowingStream { continuation in
            Task {
                do {
                    try await performStreaming(request: request, continuation: continuation)
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }

    private func performStreaming(request: ResponseRequest, continuation: AsyncThrowingStream<ResponseEvent, Error>.Continuation) async throws {
        var streamingRequest = request
        streamingRequest.stream = true

        let url = baseURL
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Add authentication header if API key is provided
        if let apiKey = apiKey {
            urlRequest.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        }

        let encoder = JSONEncoder()
        urlRequest.httpBody = try encoder.encode(streamingRequest)

        let (bytes, response) = try await session.bytes(for: urlRequest)

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw LLMError.invalidResponse
        }

        for try await line in bytes.lines {
            if line.hasPrefix("data: ") {
                let data = String(line.dropFirst(6))
                if data == "[DONE]" {
                    continuation.finish()
                    return
                }

                if let event = parseSSEEvent(data) {
                    continuation.yield(event)
                }
            }
        }
    }

    private func parseSSEEvent(_ data: String) -> ResponseEvent? {
        guard let data = data.data(using: .utf8) else { return nil }

        let decoder = JSONDecoder()
        do {
            let response = try decoder.decode(Response.self, from: data)
            return .completed(response)
        } catch {
            // Try to parse as a partial response or event
            do {
                if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
                   let eventType = json["event"] as? String {
                    switch eventType {
                    case "created":
                        return .created
                    case "in_progress":
                        return .inProgress
                    case "output_item.added":
                        if json["output_item"] is [String: Any] {
                            // Parse output item - simplified for now
                            return .outputItemAdded(.message(AssistantMessage(text: "")))
                        }
                    default:
                        let codableDict = json.reduce(into: [String: AnyCodable]()) { result, pair in
                            if let codable = AnyCodable.fromAny(pair.value) {
                                result[pair.key] = codable
                            }
                        }
                        return .unknown(eventType, codableDict)
                    }
                }
            } catch {
                return nil
            }
        }
        return nil
    }

    /// Convenience method for simple chat interactions
    public func chat(model: String, message: String, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let request = try ResponseRequest(model: model, input: [UserMessage(text: message)], previousResponseId: nil, stream: false, config: config)
        return try await respond(to: request)
    }

    /// Convenience method for chat with system prompt
    public func chat(model: String, systemPrompt: String, message: String, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let messages: [any ResponseMessage] = [SystemMessage(text: systemPrompt), UserMessage(text: message)]
        let request = try ResponseRequest(model: model, input: messages, previousResponseId: nil, stream: false, config: config)
        return try await respond(to: request)
    }

    /// Convenience method for conversation-based chat
    public func chat(conversation: ResponseConversation, config: [any ResponseConfigParameter] = []) async throws -> Response {
        let request = try conversation.generateRequest(model: "", stream: false, config: config)
        return try await respond(to: request)
    }
}
