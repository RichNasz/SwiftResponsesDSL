//
//  Configuration.swift
//  SwiftResponsesDSL
//
//  Configuration parameter structs for the SwiftResponsesDSL
//
//  Generated by AI-assisted code generation.
//  Created by Richard Naszcyniec on [Date].
//  Copyright Â© [Year] Richard Naszcyniec. All rights reserved.
//

import Foundation

// MARK: - Configuration Parameter Structs

/// Controls randomness in responses (0.0 to 2.0)
public struct Temperature: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (0.0...2.0).contains(value) else {
            throw LLMError.invalidValue("Temperature must be between 0.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.temperature = value
    }
}

/// Controls diversity via nucleus sampling (0.0 to 1.0)
public struct TopP: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (0.0...1.0).contains(value) else {
            throw LLMError.invalidValue("TopP must be between 0.0 and 1.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.topP = value
    }
}

/// Maximum number of tokens to generate (positive integer)
public struct MaxOutputTokens: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard value > 0 else {
            throw LLMError.invalidValue("MaxOutputTokens must be positive")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.maxOutputTokens = value
    }
}

/// Reduces likelihood of repeating tokens (-2.0 to 2.0)
public struct FrequencyPenalty: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (-2.0...2.0).contains(value) else {
            throw LLMError.invalidValue("FrequencyPenalty must be between -2.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.frequencyPenalty = value
    }
}

/// Reduces likelihood of repeating topics (-2.0 to 2.0)
public struct PresencePenalty: ResponseConfigParameter {
    public let value: Double
    public init(_ value: Double) throws {
        guard (-2.0...2.0).contains(value) else {
            throw LLMError.invalidValue("PresencePenalty must be between -2.0 and 2.0")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.presencePenalty = value
    }
}

/// Maximum number of tool calls allowed (1 to 128)
public struct MaxToolCalls: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard (1...128).contains(value) else {
            throw LLMError.invalidValue("MaxToolCalls must be between 1 and 128")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.maxToolCalls = value
    }
}

/// Controls tool usage behavior
public struct ToolChoice: ResponseConfigParameter {
    public let value: String
    public init(_ value: String) throws {
        let validChoices = ["none", "auto", "required"]
        guard validChoices.contains(value) else {
            throw LLMError.invalidValue("ToolChoice must be one of: \(validChoices.joined(separator: ", "))")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.toolChoice = value
    }
}

/// Number of top log probabilities to return (0 to 20)
public struct TopLogprobs: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard (0...20).contains(value) else {
            throw LLMError.invalidValue("TopLogprobs must be between 0 and 20")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.topLogprobs = value
    }
}

/// Random seed for reproducible outputs (non-negative integer)
public struct Seed: ResponseConfigParameter {
    public let value: Int
    public init(_ value: Int) throws {
        guard value >= 0 else {
            throw LLMError.invalidValue("Seed must be non-negative")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.seed = value
    }
}

/// Defines available tools for the model
public struct Tools: ResponseConfigParameter {
    public let value: [Tool]
    public init(_ value: [Tool]) throws {
        guard !value.isEmpty else {
            throw LLMError.invalidValue("Tools array cannot be empty")
        }
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.tools = value
    }
}

/// Enables parallel tool calls
public struct ParallelToolCalls: ResponseConfigParameter {
    public let value: Bool
    public init(_ value: Bool) {
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.parallelToolCalls = value
    }
}

/// Streaming options configuration
public struct StreamOptions: ResponseConfigParameter {
    public let value: [String: AnyCodable]
    public init(_ value: [String: AnyCodable]) {
        self.value = value
    }
    public func apply(to request: inout ResponseRequest) throws {
        request.streamOptions = value
    }
}
